<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Harmonic Oscillator — High Energies</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#0f172a;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;color:#e2e8f0;overflow:hidden;}

.top-bar{width:100%;height:48px;background:rgba(15,23,42,0.95);border-bottom:1px solid rgba(148,163,184,0.15);display:flex;align-items:center;padding:0 16px;gap:10px;flex-shrink:0;z-index:100;}
.top-bar h2{font-size:14px;font-weight:700;color:#f1f5f9;margin:0;white-space:nowrap;}

.info-icon-wrapper{position:relative;display:inline-flex;}
.info-icon{width:20px;height:20px;border-radius:50%;border:1.5px solid #64748b;color:#64748b;font-size:12px;font-weight:700;font-style:italic;font-family:Georgia,serif;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all 0.2s;flex-shrink:0;}
.info-icon:hover{border-color:#60a5fa;color:#60a5fa;background:rgba(96,165,250,0.1);}

.info-tooltip{display:none;position:absolute;top:calc(100% + 8px);left:0;width:320px;background:rgba(15,23,42,0.98);border:1px solid rgba(96,165,250,0.3);border-radius:8px;padding:14px;z-index:2000;box-shadow:0 8px 32px rgba(0,0,0,0.5);}
.info-tooltip::before{content:'';position:absolute;top:-6px;left:12px;width:10px;height:10px;background:rgba(15,23,42,0.98);border-left:1px solid rgba(96,165,250,0.3);border-top:1px solid rgba(96,165,250,0.3);transform:rotate(45deg);}
.info-icon-wrapper:hover .info-tooltip{display:block;}

.info-tooltip h4{font-size:13px;font-weight:700;color:#60a5fa;margin-bottom:10px;}
.info-tooltip .info-section{margin-bottom:10px;}
.info-tooltip .info-section:last-child{margin-bottom:0;}
.info-tooltip p{font-size:11px;line-height:1.6;color:#94a3b8;margin:0;}
.info-tooltip code{color:#60a5fa;font-family:'SF Mono',Consolas,monospace;font-size:11px;}
.info-tooltip strong{color:#e2e8f0;}

.outer-container{display:flex;flex-direction:column;width:100vw;height:100vh;}

.main-container{display:flex;flex:1;min-height:0;}

.plot-area{flex:1;display:flex;flex-direction:column;padding:10px;gap:8px;min-width:0;position:relative;}

.plot-row{display:flex;flex:1;gap:8px;min-height:0;}

.plot-box{flex:1;background:rgba(15,23,42,0.95);border:1px solid rgba(148,163,184,0.15);border-radius:8px;position:relative;overflow:hidden;display:flex;flex-direction:column;transition:all 0.3s ease;}
.plot-box.wide{flex:1;}
.plot-box canvas{flex:1;display:block;width:100%;height:100%;}
.plot-title{font-size:12px;font-weight:600;color:#94a3b8;padding:6px 10px 2px;letter-spacing:0.5px;text-transform:uppercase;flex-shrink:0;display:flex;align-items:center;justify-content:space-between;}
.plot-title span{flex:1;}

.maximize-btn{background:none;border:none;color:#64748b;cursor:pointer;font-size:16px;padding:2px 6px;border-radius:4px;transition:all 0.2s;display:flex;align-items:center;justify-content:center;flex-shrink:0;}
.maximize-btn:hover{color:#e2e8f0;background:rgba(148,163,184,0.15);}

.plot-box.maximized{position:absolute!important;top:0!important;left:0!important;right:0!important;bottom:0!important;width:100%!important;height:100%!important;z-index:1000!important;border-radius:0!important;flex:none!important;}

.sidebar{width:280px;flex-shrink:0;background:rgba(15,23,42,0.9);backdrop-filter:blur(12px);border-left:1px solid rgba(148,163,184,0.1);display:flex;flex-direction:column;padding:16px;gap:16px;overflow-y:auto;z-index:1001;}

.sidebar h3{font-size:11px;font-weight:600;color:#64748b;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;}

.stat-row{display:flex;justify-content:space-between;align-items:center;font-size:13px;padding:3px 0;}
.stat-label{color:#94a3b8;display:flex;align-items:center;}
.stat-label .katex{font-size:0.85em;}
.stat-value{color:#f1f5f9;font-weight:600;font-variant-numeric:tabular-nums;}
.stat-value.highlight{color:#fbbf24;font-size:15px;}

.control-group{display:flex;flex-direction:column;gap:6px;}
.control-group label{font-size:12px;color:#94a3b8;}
.slider-row{display:flex;align-items:center;gap:10px;}
.slider-row input[type=range]{flex:1;-webkit-appearance:none;appearance:none;height:6px;background:rgba(148,163,184,0.2);border-radius:3px;outline:none;}
.slider-row input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;background:#3b82f6;border-radius:50%;cursor:pointer;}
.slider-row input[type=range]::-moz-range-thumb{width:16px;height:16px;background:#3b82f6;border-radius:50%;cursor:pointer;border:none;}
.slider-val{min-width:30px;text-align:right;font-weight:600;font-size:14px;color:#f1f5f9;}

.btn{padding:8px 16px;background:#3b82f6;border:none;border-radius:6px;color:white;cursor:pointer;font-size:13px;font-weight:600;transition:background 0.2s;}
.btn:hover{background:#2563eb;}
.btn.paused{background:#ef4444;}

.legend{display:flex;flex-wrap:wrap;gap:10px;font-size:11px;padding:4px 10px;flex-shrink:0;}
.legend-item{display:flex;align-items:center;gap:4px;}
.legend-dot{width:10px;height:3px;border-radius:2px;}

.divider{height:1px;background:rgba(148,163,184,0.1);}

/* KaTeX color overrides for dark theme */
.sidebar .katex .mord,
.sidebar .katex .mbin,
.sidebar .katex .mrel,
.sidebar .katex .mopen,
.sidebar .katex .mclose,
.sidebar .katex .mpunct,
.sidebar .katex .mop,
.sidebar .katex .minner,
.sidebar .katex .mfrac,
.sidebar .katex .msupsub {
  color: inherit;
}
.sidebar .katex {
  color: inherit;
}

@media(max-width:900px){
  .sidebar{width:220px;padding:10px;}
  .info-tooltip{width:260px;}
}
</style>
</head>
<body>
<div class="outer-container">
  <div class="top-bar">
    <h2>⚛ Harmonic Oscillator — High Energies</h2>
    <div class="info-icon-wrapper">
      <div class="info-icon">i</div>
      <div class="info-tooltip">
        <h4>About the Simulation</h4>
        <div class="info-section">
          <p>Visualizing the classical-quantum correspondence at high energies. Natural units: <code>ℏ = m = ω = 1</code>.</p>
        </div>
        <div class="info-section">
          <p>As <code>n → ∞</code>, <code>ΔE/Eₙ → 0</code>: energy spacing becomes negligible relative to total energy. The coarse-grained <code>|Ψₙ|²</code> approaches the classical probability distribution <code>P_cl</code>. Full classical dynamics (a localized moving particle) requires coherent-state superpositions.</p>
        </div>
        <div class="info-section">
          <p><strong>Key physics:</strong> The probability density <code>|Ψₙ|²</code> is time-independent for energy eigenstates — only Re(Ψ) and Im(Ψ) oscillate (via the phase <code>e<sup>−iEₙt</sup></code>). At high n, the coarse-grained <code>|Ψₙ|²</code> converges to the classical distribution <code>P_cl = 1/(π√(2E − ξ²))</code>, shown as the dashed orange curve on the density plot.</p>
        </div>
        <div class="info-section">
          <p>The classical curve <code>P_cl</code> diverges at the turning points; it is clipped to the plot range for display so it does not extend off the chart.</p>
        </div>
      </div>
    </div>
  </div>
  <div class="main-container">
    <div class="plot-area">
      <div class="plot-row">
        <div class="plot-box" id="plotPotential">
          <div class="plot-title"><span>Harmonic Potential & Energy Levels</span><button class="maximize-btn" title="Maximize" onclick="toggleMaximize('plotPotential')">⛶</button></div>
          <canvas id="cvPotential"></canvas>
        </div>
      </div>
      <div class="plot-row">
        <div class="plot-box" id="plotWavefunction">
          <div class="plot-title"><span>Wavefunction</span><button class="maximize-btn" title="Maximize" onclick="toggleMaximize('plotWavefunction')">⛶</button></div>
          <canvas id="cvWavefunction"></canvas>
          <div class="legend">
            <div class="legend-item"><div class="legend-dot" style="background:#60a5fa"></div>Re(Ψ)</div>
            <div class="legend-item"><div class="legend-dot" style="background:#f472b6"></div>Im(Ψ)</div>
            <div class="legend-item"><div class="legend-dot" style="background:#fbbf24;opacity:0.5"></div>|Ψ| envelope</div>
          </div>
        </div>
        <div class="plot-box" id="plotDensity">
          <div class="plot-title"><span>Probability Density</span><button class="maximize-btn" title="Maximize" onclick="toggleMaximize('plotDensity')">⛶</button></div>
          <canvas id="cvDensity"></canvas>
          <div class="legend">
            <div class="legend-item"><div class="legend-dot" style="background:#34d399"></div>|Ψₙ|²</div>
            <div class="legend-item"><div class="legend-dot" style="background:#fb923c;border-top:1.5px dashed #fb923c;height:0;width:14px;border-radius:0;"></div>P_cl (classical)</div>
          </div>
        </div>
      </div>
    </div>
    <div class="sidebar">
      <h3>Controls</h3>
      <div class="control-group">
        <label>Energy Level n</label>
        <div class="slider-row">
          <input type="range" id="sliderN" min="0" max="60" value="40" step="1">
          <span class="slider-val" id="valN">40</span>
        </div>
      </div>
      <div class="control-group">
        <label>Animation Speed</label>
        <div class="slider-row">
          <input type="range" id="sliderSpeed" min="0.1" max="3" value="1" step="0.1">
          <span class="slider-val" id="valSpeed">1.0</span>
        </div>
      </div>
      <div style="display:flex;gap:8px;">
        <button class="btn" id="btnPlayPause" style="flex:1;">⏸ Pause</button>
        <button class="btn" id="btnReset" style="flex:0;background:#475569;">↺</button>
      </div>
      <div class="divider"></div>
      <h3>Quantum Numbers</h3>
      <div class="stat-row"><span class="stat-label" id="labelN"></span><span class="stat-value" id="statN">40</span></div>
      <div class="stat-row"><span class="stat-label" id="labelE"></span><span class="stat-value" id="statE">40.5</span></div>
      <div class="stat-row"><span class="stat-label" id="labelDE"></span><span class="stat-value" id="statDE">1.000</span></div>
      <div class="stat-row"><span class="stat-label" id="labelNodes"></span><span class="stat-value" id="statNodes">40</span></div>
      <div class="divider"></div>
      <h3>Continuum Illusion</h3>
      <div class="stat-row">
        <span class="stat-label" id="labelRatio"></span>
        <span class="stat-value highlight" id="statRatio">0.0247</span>
      </div>
      <div class="divider"></div>
      <h3>Classical Turning Points</h3>
      <div class="stat-row"><span class="stat-label" id="labelTP"></span><span class="stat-value" id="statTP">±9.00</span></div>
      <div class="divider"></div>
      <h3>Time Evolution</h3>
      <div class="stat-row"><span class="stat-label" id="labelPeriodCl"></span><span class="stat-value" id="statPeriodCl">6.283</span></div>
      <div class="stat-row"><span class="stat-label" id="labelPeriodPh"></span><span class="stat-value" id="statPeriodPh">0.155</span></div>
      <div class="stat-row"><span class="stat-label" id="labelNorm"></span><span class="stat-value" id="statNorm">1.0000</span></div>
    </div>
  </div>
</div>

<script>
(function(){

// --- Render KaTeX labels ---
function renderKatexLabels() {
  const labels = [
    { id: 'labelN', tex: 'n' },
    { id: 'labelE', tex: 'E_n = \\left(n + \\tfrac{1}{2}\\right)\\hbar\\omega' },
    { id: 'labelDE', tex: 'E_{n+1} - E_n = \\hbar\\omega' },
    { id: 'labelNodes', tex: '\\text{Nodes}' },
    { id: 'labelRatio', tex: '\\Delta E / E_n = \\dfrac{1}{n + \\frac{1}{2}}' },
    { id: 'labelTP', tex: '\\xi_{\\mathrm{tp}} = \\pm\\sqrt{2n+1}' },
    { id: 'labelPeriodCl', tex: 'T_{\\mathrm{cl}} = 2\\pi / \\omega' },
    { id: 'labelPeriodPh', tex: 'T_{\\mathrm{phase}} = 2\\pi / E_n' },
    { id: 'labelNorm', tex: '\\displaystyle\\int |\\Psi|^2 \\, d\\xi' }
  ];
  labels.forEach(function(item) {
    const el = document.getElementById(item.id);
    if(el) {
      try {
        katex.render(item.tex, el, { throwOnError: false, displayMode: false });
      } catch(e) {
        el.textContent = item.tex;
      }
    }
  });
}

// Wait for KaTeX to load, then render
function waitForKatex(cb) {
  if(typeof katex !== 'undefined') {
    cb();
  } else {
    setTimeout(function(){ waitForKatex(cb); }, 100);
  }
}
waitForKatex(renderKatexLabels);

// --- Maximize functionality ---
let currentMaximized = null;

window.toggleMaximize = function(plotId) {
  const el = document.getElementById(plotId);
  if(!el) return;
  const btn = el.querySelector('.maximize-btn');
  if(!btn) return;
  
  if(currentMaximized === plotId) {
    el.classList.remove('maximized');
    btn.textContent = '⛶';
    btn.title = 'Maximize';
    currentMaximized = null;
  } else {
    if(currentMaximized) {
      const prevEl = document.getElementById(currentMaximized);
      if(prevEl) {
        prevEl.classList.remove('maximized');
        const prevBtn = prevEl.querySelector('.maximize-btn');
        if(prevBtn) {
          prevBtn.textContent = '⛶';
          prevBtn.title = 'Maximize';
        }
      }
    }
    el.classList.add('maximized');
    btn.textContent = '✕';
    btn.title = 'Restore';
    currentMaximized = plotId;
  }
  
  needsResize = true;
};

document.addEventListener('keydown', function(e) {
  if(e.key === 'Escape' && currentMaximized) {
    toggleMaximize(currentMaximized);
  }
});

// --- State ---
let n = 40;
let playing = true;
let animSpeed = 1.0;
let time = 0;
let lastTimestamp = 0;
let normValue = 1.0;
let nodeCount = 0;

// --- Fixed axis ranges ---
const FIXED_XI_MAX = 15;
const FIXED_V_MAX = 70;

function getWavefunctionYMax(nn) {
  if(!psiCache || psiN !== nn) return 0.5;
  let maxAbs = 0;
  for(let i = 0; i < psiCache.length; i++) {
    const a = Math.abs(psiCache[i]);
    if(a > maxAbs) maxAbs = a;
  }
  const padded = maxAbs * 1.4;
  const computed = Math.ceil(padded / 0.05) * 0.05;
  return Math.max(computed, 0.05);
}

function getDensityYMax(nn) {
  if(!psiCache || psiN !== nn) return 0.25;
  let maxDens = 0;
  for(let i = 0; i < psiCache.length; i++) {
    const d = psiCache[i] * psiCache[i];
    if(d > maxDens) maxDens = d;
  }
  // Also consider classical distribution peak for y-axis scaling
  const tp = Math.sqrt(2*nn + 1);
  // P_cl diverges at turning points; sample slightly inside
  const xiSample = tp * 0.95;
  const Pcl = 1.0 / (Math.PI * Math.sqrt(Math.max(1e-12, 2*(nn+0.5) - xiSample*xiSample)));
  const maxVal = Math.max(maxDens, Pcl);
  const padded = maxVal * 1.4;
  const computed = Math.ceil(padded / 0.01) * 0.01;
  return Math.max(computed, 0.01);
}

function getXiMax(nn) {
  const tp = Math.sqrt(2 * nn + 1);
  const padded = tp * 1.35;
  return Math.max(Math.ceil(padded), 3);
}

// --- DOM ---
const sliderN = document.getElementById('sliderN');
const valN = document.getElementById('valN');
const sliderSpeed = document.getElementById('sliderSpeed');
const valSpeed = document.getElementById('valSpeed');
const btnPlay = document.getElementById('btnPlayPause');
const btnReset = document.getElementById('btnReset');

const cvP = document.getElementById('cvPotential');
const cvW = document.getElementById('cvWavefunction');
const cvD = document.getElementById('cvDensity');
const ctxP = cvP.getContext('2d');
const ctxW = cvW.getContext('2d');
const ctxD = cvD.getContext('2d');

// --- Canvas size cache (avoid resize every frame) ---
let canvasSizes = { cvP: null, cvW: null, cvD: null };
let needsResize = true;

function resizeCanvas(cv) {
  const rect = cv.parentElement.getBoundingClientRect();
  const titleEl = cv.parentElement.querySelector('.plot-title');
  const legendEl = cv.parentElement.querySelector('.legend');
  const titleH = titleEl ? titleEl.offsetHeight : 0;
  const legendH = legendEl ? legendEl.offsetHeight : 0;
  const w = Math.max(1, Math.floor(rect.width));
  const h = Math.max(1, Math.floor(rect.height - titleH - legendH));
  const dpr = window.devicePixelRatio || 1;
  cv.width = w * dpr;
  cv.height = h * dpr;
  cv.style.width = w + 'px';
  cv.style.height = h + 'px';
  const ctx = cv.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {w, h};
}

function getCanvasSize(cv) {
  const w = parseInt(cv.style.width) || cv.parentElement.clientWidth;
  const h = parseInt(cv.style.height) || cv.parentElement.clientHeight;
  return {w, h};
}

function resizeAll() {
  canvasSizes.cvP = resizeCanvas(cvP);
  canvasSizes.cvW = resizeCanvas(cvW);
  canvasSizes.cvD = resizeCanvas(cvD);
  needsResize = false;
}

window.addEventListener('resize', function() { needsResize = true; });
setTimeout(resizeAll, 50);

// --- Wavefunction cache ---
let psiCache = null;
let psiXi = null;
let psiN = -1;
const NUM_POINTS = 2400;

function computeWavefunction(nn) {
  const xm = Math.max(FIXED_XI_MAX, getXiMax(nn) + 2);
  const pts = nn >= 50 ? 4000 : NUM_POINTS;
  const xi = new Float64Array(pts);
  const dx = 2*xm/(pts-1);
  for(let i=0;i<pts;i++) xi[i] = -xm + i*dx;

  const psi = new Float64Array(pts);
  
  if(nn === 0) {
    const c = Math.pow(Math.PI, -0.25);
    for(let i=0;i<pts;i++) psi[i] = c * Math.exp(-xi[i]*xi[i]/2);
  } else {
    const psiPrev = new Float64Array(pts);
    const psiCurr = new Float64Array(pts);
    const c = Math.pow(Math.PI, -0.25);
    
    for(let i=0;i<pts;i++) {
      psiPrev[i] = c * Math.exp(-xi[i]*xi[i]/2);
      psiCurr[i] = Math.sqrt(2) * xi[i] * psiPrev[i];
    }
    
    if(nn === 1) {
      for(let i=0;i<pts;i++) psi[i] = psiCurr[i];
    } else {
      for(let k=1; k<nn; k++) {
        const a = Math.sqrt(2/(k+1));
        const b = Math.sqrt(k/(k+1));
        for(let i=0;i<pts;i++) {
          const next = xi[i]*a*psiCurr[i] - b*psiPrev[i];
          psiPrev[i] = psiCurr[i];
          psiCurr[i] = next;
        }
      }
      for(let i=0;i<pts;i++) psi[i] = psiCurr[i];
    }
  }
  
  // Normalization check
  let norm2 = 0;
  for(let i=0; i<pts-1; i++) {
    const dxi = xi[i+1] - xi[i];
    norm2 += 0.5 * (psi[i]*psi[i] + psi[i+1]*psi[i+1]) * dxi;
  }
  normValue = norm2;
  if(Math.abs(norm2 - 1.0) > 1e-6) {
    const scale = 1.0 / Math.sqrt(norm2);
    for(let i=0;i<pts;i++) psi[i] *= scale;
    normValue = 1.0;
  }
  
  // Count nodes (zero crossings)
  nodeCount = 0;
  for(let i=0; i<pts-1; i++) {
    if(psi[i] * psi[i+1] < 0) nodeCount++;
  }
  
  psiCache = psi;
  psiXi = xi;
  psiN = nn;
}

// --- Drawing helpers ---
function mapX(xi, xm, w, margin) {
  return margin + (xi + xm)/(2*xm) * (w - 2*margin);
}
function mapY(val, vmin, vmax, h, margin) {
  const range = vmax - vmin;
  if(range === 0) return margin + (h - 2*margin) / 2;
  return margin + (1 - (val - vmin) / range) * (h - 2*margin);
}

function smartTickFormat(val, range) {
  if(range >= 10) return val.toFixed(0);
  if(range >= 1) return val.toFixed(1);
  if(range >= 0.1) return val.toFixed(2);
  return val.toFixed(3);
}

function drawAxes(ctx, w, h, margin, xLabel, yLabel, xm, ymin, ymax, numXTicks, numYTicks) {
  ctx.strokeStyle = 'rgba(148,163,184,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(margin, margin);
  ctx.lineTo(margin, h-margin);
  ctx.lineTo(w-margin, h-margin);
  ctx.stroke();
  
  ctx.fillStyle = '#64748b';
  ctx.font = '10px -apple-system, sans-serif';
  ctx.textAlign = 'center';
  
  const yRange = ymax - ymin;
  
  for(let i=0;i<=numXTicks;i++) {
    const frac = i/numXTicks;
    const xVal = -xm + frac*2*xm;
    const px = margin + frac*(w-2*margin);
    ctx.fillText(smartTickFormat(xVal, 2*xm), px, h-margin+14);
    ctx.strokeStyle = 'rgba(148,163,184,0.1)';
    ctx.beginPath();
    ctx.moveTo(px, margin);
    ctx.lineTo(px, h-margin);
    ctx.stroke();
  }
  
  ctx.textAlign = 'right';
  for(let i=0;i<=numYTicks;i++) {
    const frac = i/numYTicks;
    const yVal = ymin + frac*(ymax-ymin);
    const py = h - margin - frac*(h-2*margin);
    ctx.fillText(smartTickFormat(yVal, yRange), margin-4, py+3);
    ctx.strokeStyle = 'rgba(148,163,184,0.1)';
    ctx.beginPath();
    ctx.moveTo(margin, py);
    ctx.lineTo(w-margin, py);
    ctx.stroke();
  }
  
  ctx.fillStyle = '#94a3b8';
  ctx.font = '11px -apple-system, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(xLabel, w/2, h-2);
  ctx.save();
  ctx.translate(12, h/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();
}

// --- Draw Potential (fixed axes) ---
function drawPotential() {
  const {w,h} = canvasSizes.cvP;
  if(!w || !h || w <= 90 || h <= 90) return;
  const ctx = ctxP;
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,w,h);
  
  const margin = 45;
  const xm = FIXED_XI_MAX;
  const Vmax = FIXED_V_MAX;
  
  drawAxes(ctx, w, h, margin, 'ξ', 'V(ξ), E', xm, 0, Vmax, 6, 5);
  
  // Draw parabola
  ctx.strokeStyle = '#475569';
  ctx.lineWidth = 2;
  ctx.beginPath();
  let started = false;
  for(let px=margin; px<=w-margin; px++) {
    const xi = -xm + (px-margin)/(w-2*margin)*2*xm;
    const V = 0.5*xi*xi;
    if(V > Vmax) { started = false; continue; }
    const py = mapY(V, 0, Vmax, h, margin);
    if(!started){ctx.moveTo(px,py);started=true;} else ctx.lineTo(px,py);
  }
  ctx.stroke();
  
  // Fill under parabola
  ctx.fillStyle = 'rgba(71,85,105,0.08)';
  ctx.beginPath();
  const fillPts = [];
  for(let px=margin; px<=w-margin; px++) {
    const xi = -xm + (px-margin)/(w-2*margin)*2*xm;
    const V = 0.5*xi*xi;
    if(V > Vmax) continue;
    const py = mapY(V, 0, Vmax, h, margin);
    fillPts.push({px, py});
  }
  if(fillPts.length > 0) {
    ctx.moveTo(fillPts[0].px, h-margin);
    for(const p of fillPts) ctx.lineTo(p.px, p.py);
    ctx.lineTo(fillPts[fillPts.length-1].px, h-margin);
    ctx.closePath();
    ctx.fill();
  }
  
  // Draw energy levels
  const nShow = 60;
  for(let k=0; k<=nShow; k++) {
    const E = k + 0.5;
    if(E > Vmax) break;
    const py = mapY(E, 0, Vmax, h, margin);
    
    const tp = Math.sqrt(2*k+1);
    const pxL = mapX(-tp, xm, w, margin);
    const pxR = mapX(tp, xm, w, margin);
    
    if(k === n) {
      ctx.strokeStyle = '#fbbf24';
      ctx.lineWidth = 2.5;
      ctx.shadowColor = '#fbbf24';
      ctx.shadowBlur = 6;
    } else if(Math.abs(k-n) <= 2) {
      ctx.strokeStyle = 'rgba(251,191,36,0.5)';
      ctx.lineWidth = 1.5;
      ctx.shadowBlur = 0;
    } else {
      ctx.strokeStyle = 'rgba(96,165,250,0.25)';
      ctx.lineWidth = 1;
      ctx.shadowBlur = 0;
    }
    
    ctx.beginPath();
    ctx.moveTo(Math.max(margin, pxL), py);
    ctx.lineTo(Math.min(w-margin, pxR), py);
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    if(k === n) {
      ctx.fillStyle = '#fbbf24';
      ctx.font = 'bold 11px -apple-system, sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('n=' + k + ', E=' + E.toFixed(1), Math.min(w-margin, pxR)+4, py+4);
    }
  }
  
  // Draw turning point dashed lines
  const tp = Math.sqrt(2*n+1);
  const Esel = n + 0.5;
  const pyE = mapY(Esel, 0, Vmax, h, margin);
  ctx.setLineDash([4,3]);
  ctx.strokeStyle = 'rgba(251,191,36,0.4)';
  ctx.lineWidth = 1;
  [tp, -tp].forEach(function(t) {
    const px = mapX(t, xm, w, margin);
    ctx.beginPath();
    ctx.moveTo(px, pyE);
    ctx.lineTo(px, h-margin);
    ctx.stroke();
  });
  ctx.setLineDash([]);
}

// --- Draw Wavefunction (dynamic axes) ---
function drawWavefunction() {
  const {w,h} = canvasSizes.cvW;
  if(!w || !h || w <= 90 || h <= 90) return;
  const ctx = ctxW;
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,w,h);
  
  if(!psiCache || psiN !== n) computeWavefunction(n);
  
  const margin = 45;
  const xm = getXiMax(n);
  const pts = psiCache.length;
  const ymax = getWavefunctionYMax(n);
  
  drawAxes(ctx, w, h, margin, 'ξ', 'Ψ(ξ,t)', xm, -ymax, ymax, 6, 4);
  
  const phase = -(n + 0.5) * time;
  const cosP = Math.cos(phase);
  const sinP = Math.sin(phase);
  
  // Turning point dashed lines
  const tp = Math.sqrt(2*n+1);
  ctx.setLineDash([4,3]);
  ctx.strokeStyle = 'rgba(148,163,184,0.3)';
  ctx.lineWidth = 1;
  [tp,-tp].forEach(function(t) {
    const px = mapX(t, xm, w, margin);
    if(px >= margin && px <= w - margin) {
      ctx.beginPath();
      ctx.moveTo(px, margin);
      ctx.lineTo(px, h-margin);
      ctx.stroke();
    }
  });
  ctx.setLineDash([]);
  
  // Envelope ±|ψ|
  ctx.strokeStyle = 'rgba(251,191,36,0.25)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  let envStarted = false;
  for(let i=0;i<pts;i++) {
    const px = mapX(psiXi[i], xm, w, margin);
    if(px < margin || px > w - margin) { envStarted = false; continue; }
    const py = mapY(Math.abs(psiCache[i]), -ymax, ymax, h, margin);
    if(!envStarted){ctx.moveTo(px,py);envStarted=true;} else ctx.lineTo(px,py);
  }
  ctx.stroke();
  ctx.beginPath();
  envStarted = false;
  for(let i=0;i<pts;i++) {
    const px = mapX(psiXi[i], xm, w, margin);
    if(px < margin || px > w - margin) { envStarted = false; continue; }
    const py = mapY(-Math.abs(psiCache[i]), -ymax, ymax, h, margin);
    if(!envStarted){ctx.moveTo(px,py);envStarted=true;} else ctx.lineTo(px,py);
  }
  ctx.stroke();
  
  // Re(Ψ)
  ctx.strokeStyle = '#60a5fa';
  ctx.lineWidth = 1.8;
  ctx.beginPath();
  let reStarted = false;
  for(let i=0;i<pts;i++) {
    const re = psiCache[i] * cosP;
    const px = mapX(psiXi[i], xm, w, margin);
    if(px < margin || px > w - margin) { reStarted = false; continue; }
    const py = mapY(re, -ymax, ymax, h, margin);
    if(!reStarted){ctx.moveTo(px,py);reStarted=true;} else ctx.lineTo(px,py);
  }
  ctx.stroke();
  
  // Im(Ψ)
  ctx.strokeStyle = '#f472b6';
  ctx.lineWidth = 1.8;
  ctx.beginPath();
  let imStarted = false;
  for(let i=0;i<pts;i++) {
    const im = psiCache[i] * sinP;
    const px = mapX(psiXi[i], xm, w, margin);
    if(px < margin || px > w - margin) { imStarted = false; continue; }
    const py = mapY(im, -ymax, ymax, h, margin);
    if(!imStarted){ctx.moveTo(px,py);imStarted=true;} else ctx.lineTo(px,py);
  }
  ctx.stroke();
  
  // Zero line
  ctx.strokeStyle = 'rgba(148,163,184,0.2)';
  ctx.lineWidth = 1;
  const y0 = mapY(0, -ymax, ymax, h, margin);
  ctx.beginPath();
  ctx.moveTo(margin, y0);
  ctx.lineTo(w-margin, y0);
  ctx.stroke();
}

// --- Draw Probability Density (dynamic axes) ---
function drawDensity() {
  const {w,h} = canvasSizes.cvD;
  if(!w || !h || w <= 90 || h <= 90) return;
  const ctx = ctxD;
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,w,h);
  
  if(!psiCache || psiN !== n) computeWavefunction(n);
  
  const margin = 45;
  const xm = getXiMax(n);
  const pts = psiCache.length;
  
  const density = new Float64Array(pts);
  for(let i=0;i<pts;i++) {
    density[i] = psiCache[i]*psiCache[i];
  }
  
  const tp = Math.sqrt(2*n+1);
  const E = n + 0.5;
  const ymax = getDensityYMax(n);
  
  drawAxes(ctx, w, h, margin, 'ξ', '|Ψ|²', xm, 0, ymax, 6, 4);
  
  // Turning point dashed lines
  ctx.setLineDash([4,3]);
  ctx.strokeStyle = 'rgba(148,163,184,0.3)';
  ctx.lineWidth = 1;
  [tp,-tp].forEach(function(t) {
    const px = mapX(t, xm, w, margin);
    if(px >= margin && px <= w - margin) {
      ctx.beginPath();
      ctx.moveTo(px, margin);
      ctx.lineTo(px, h-margin);
      ctx.stroke();
    }
  });
  ctx.setLineDash([]);
  
  // Classical probability distribution: P_cl(ξ) = 1 / (π √(2E - ξ²))
  // Only defined for |ξ| < ξ_tp = √(2E)
  ctx.setLineDash([6,4]);
  ctx.strokeStyle = '#fb923c';
  ctx.lineWidth = 2;
  ctx.beginPath();
  let clStarted = false;
  const xiTp = Math.sqrt(2*E);
  // Stay slightly inside turning points to avoid divergence
  const clMargin = 0.03 * xiTp;
  for(let px=margin; px<=w-margin; px++) {
    const xi = -xm + (px-margin)/(w-2*margin)*2*xm;
    const absXi = Math.abs(xi);
    if(absXi >= xiTp - clMargin) {
      if(clStarted) { clStarted = false; }
      continue;
    }
    const arg = 2*E - xi*xi;
    if(arg <= 0) continue;
    const Pcl = 1.0 / (Math.PI * Math.sqrt(arg));
    if(Pcl > ymax * 2) continue; // skip near-divergent points
    const clampedPcl = Math.min(Pcl, ymax);
    const py = mapY(clampedPcl, 0, ymax, h, margin);
    if(!clStarted) { ctx.moveTo(px, py); clStarted = true; }
    else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Quantum |Ψ|² fill
  ctx.fillStyle = 'rgba(52,211,153,0.15)';
  ctx.beginPath();
  let fillStarted = false;
  let firstPx = margin, lastPx = margin;
  for(let i=0;i<pts;i++) {
    const px = mapX(psiXi[i], xm, w, margin);
    if(px < margin || px > w - margin) {
      if(fillStarted) {
        ctx.lineTo(lastPx, h-margin);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        fillStarted = false;
      }
      continue;
    }
    const d = Math.min(density[i], ymax);
    const py = mapY(d, 0, ymax, h, margin);
    if(!fillStarted) {
      ctx.moveTo(px, h-margin);
      ctx.lineTo(px, py);
      firstPx = px;
      fillStarted = true;
    } else {
      ctx.lineTo(px, py);
    }
    lastPx = px;
  }
  if(fillStarted) {
    ctx.lineTo(lastPx, h-margin);
    ctx.closePath();
    ctx.fill();
  }
  
  // Quantum |Ψ|² line
  ctx.strokeStyle = '#34d399';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  let lineStarted = false;
  for(let i=0;i<pts;i++) {
    const px = mapX(psiXi[i], xm, w, margin);
    if(px < margin || px > w - margin) { lineStarted = false; continue; }
    const d = Math.min(density[i], ymax);
    const py = mapY(d, 0, ymax, h, margin);
    if(!lineStarted){ctx.moveTo(px,py);lineStarted=true;} else ctx.lineTo(px,py);
  }
  ctx.stroke();
}

// --- Update stats ---
function updateStats() {
  const E = n + 0.5;
  const ratio = 1/(n+0.5);
  const tp = Math.sqrt(2*n+1);
  const phasePeriod = 2*Math.PI / E;
  document.getElementById('statN').textContent = n;
  document.getElementById('statE').textContent = E.toFixed(1);
  document.getElementById('statDE').textContent = '1.000';
  document.getElementById('statNodes').textContent = nodeCount;
  document.getElementById('statRatio').textContent = ratio.toFixed(4);
  document.getElementById('statTP').textContent = '±' + tp.toFixed(2);
  document.getElementById('statPeriodCl').textContent = (2*Math.PI).toFixed(3);
  document.getElementById('statPeriodPh').textContent = phasePeriod.toFixed(3);
  document.getElementById('statNorm').textContent = normValue.toFixed(4);
}

// --- Controls ---
sliderN.addEventListener('input', function() {
  let val = parseInt(this.value, 10);
  if(isNaN(val)) val = 40;
  n = Math.max(0, Math.min(60, val));
  this.value = n;
  valN.textContent = n;
  computeWavefunction(n);
  updateStats();
});

sliderSpeed.addEventListener('input', function() {
  let val = parseFloat(this.value);
  if(isNaN(val) || val <= 0) val = 1;
  animSpeed = Math.max(0.1, Math.min(3, val));
  this.value = animSpeed;
  valSpeed.textContent = animSpeed.toFixed(1);
});

btnPlay.addEventListener('click', function() {
  playing = !playing;
  this.textContent = playing ? '⏸ Pause' : '▶ Play';
  this.classList.toggle('paused', !playing);
  if(playing) lastTimestamp = performance.now();
});

btnReset.addEventListener('click', function() {
  time = 0;
  updateStats();
});

// --- Main loop ---
function animate(timestamp) {
  if(!lastTimestamp) lastTimestamp = timestamp;
  const dt = (timestamp - lastTimestamp) / 1000;
  lastTimestamp = timestamp;
  
  if(playing) {
    time += dt * animSpeed;
    if(time > 2*Math.PI) time -= 2*Math.PI;
  }
  
  // Only resize canvases when needed (window resize / maximize)
  if(needsResize) {
    resizeAll();
  }
  
  drawPotential();
  drawWavefunction();
  drawDensity();
  updateStats();
  
  requestAnimationFrame(animate);
}

// --- Init ---
computeWavefunction(n);
resizeAll();
requestAnimationFrame(animate);

})();
</script>
</body>
</html>
