<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Evolution ~ Quantum Harmonic Oscillator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: #0a0e1a; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            color: #e2e8f0;
        }
        
        .header-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10, 14, 26, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(99, 102, 241, 0.2);
            padding: 8px 20px;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        
        .title-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .title {
            font-size: 16px;
            font-weight: 600;
            color: #a5b4fc;
            letter-spacing: 0.5px;
        }
        
        .info-icon-wrap {
            position: relative;
            display: inline-flex;
        }
        
        .info-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1.5px solid rgba(165, 180, 252, 0.6);
            background: rgba(99, 102, 241, 0.15);
            color: #a5b4fc;
            font-size: 12px;
            font-weight: 600;
            font-style: italic;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: help;
            transition: background 0.2s, border-color 0.2s;
        }
        
        .info-icon:hover {
            background: rgba(99, 102, 241, 0.3);
            border-color: #a5b4fc;
        }
        
        .info-tooltip {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 8px;
            width: 320px;
            max-width: 90vw;
            padding: 14px;
            background: rgba(15, 23, 42, 0.98);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            z-index: 1100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
        }
        
        .info-icon-wrap:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
        }
        
        .info-tooltip .info-tooltip-title {
            font-size: 11px;
            font-weight: 600;
            color: #a5b4fc;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }
        
        .info-tooltip .info-panel {
            font-size: 11px;
            line-height: 1.6;
        }
        
        .info-tooltip .info-panel p {
            color: #94a3b8;
            margin-bottom: 8px;
        }
        
        .info-tooltip .info-panel .highlight {
            color: #34d399;
            font-weight: 600;
        }
        
        .info-tooltip .info-panel .formula {
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 6px;
        }
        
        .main-container {
            position: fixed;
            top: 45px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            gap: 15px;
            padding: 15px;
        }
        
        .potential-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        .potential-section .section-header,
        .phase-space-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .potential-section .section-header {
            background: rgba(10, 14, 26, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 8px;
            padding: 6px 12px;
            margin-bottom: 6px;
        }
        
        .potential-section .section-header h3,
        .phase-space-header h3 {
            color: #a5b4fc;
            font-size: 12px;
            margin: 0;
            flex: 1;
        }
        
        .maximize-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 6px;
            background: rgba(99, 102, 241, 0.2);
            color: #a5b4fc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            line-height: 1;
            transition: background 0.2s, color 0.2s;
            flex-shrink: 0;
        }
        
        .maximize-btn:hover {
            background: rgba(99, 102, 241, 0.4);
            color: #c4b5fd;
        }
        
        .main-container.maximized-potential .phase-space-section {
            display: none !important;
        }
        
        .main-container.maximized-phase .potential-section {
            display: none !important;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            background: rgba(10, 14, 26, 0.5);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .phase-space-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        #phase-space-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
        }
        
        .phase-space-header {
            background: rgba(10, 14, 26, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 8px;
            padding: 6px 12px;
        }
        
        #phase-canvas-wrapper {
            flex: 1;
            background: rgba(10, 14, 26, 0.5);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            min-height: 0;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Right Panel Styles */
        .right-panel {
            width: 280px;
            min-width: 260px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        .panel-section {
            background: rgba(10, 14, 26, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            padding: 14px;
        }
        
        .panel-section-title {
            font-size: 11px;
            font-weight: 600;
            color: #a5b4fc;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .stat-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(99, 102, 241, 0.1);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid rgba(99, 102, 241, 0.2);
            flex: 1;
            min-width: 80px;
        }
        
        .stat-label {
            color: #94a3b8;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            color: #a5b4fc;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            font-size: 12px;
        }
        
        .control-group {
            margin-bottom: 14px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-label {
            font-size: 11px;
            color: #94a3b8;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .control-label .value {
            color: #a5b4fc;
            font-weight: 600;
        }
        
        .slider-container {
            position: relative;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(99, 102, 241, 0.2);
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #818cf8, #6366f1);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
        }
        
        .btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        
        .btn-secondary {
            background: rgba(99, 102, 241, 0.1);
            color: #a5b4fc;
            border: 1px solid rgba(99, 102, 241, 0.3);
        }
        
        .btn-secondary:hover {
            background: rgba(99, 102, 241, 0.2);
        }
        
        .btn-row {
            display: flex;
            gap: 8px;
        }
        
        .btn-row .btn {
            flex: 1;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 11px;
            color: #94a3b8;
            margin-top: 10px;
        }
        
        .checkbox {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 2px solid rgba(99, 102, 241, 0.4);
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .checkbox.checked {
            background: #6366f1;
            border-color: #6366f1;
        }
        
        .checkbox.checked::after {
            content: '‚úì';
            color: white;
            font-size: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 11px;
            color: #94a3b8;
        }
        
        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        .legend-color.potential {
            background: linear-gradient(90deg, #475569, #64748b);
        }
        
        .legend-color.wavefunction {
            background: linear-gradient(90deg, rgba(99, 102, 241, 0.3), #818cf8);
            height: 12px;
        }
        
        .legend-color.classical {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #1e293b;
            border: 2px solid #f472b6;
        }
        
        .legend-color.ellipse {
            width: 16px;
            height: 12px;
            border-radius: 50%;
            background: rgba(52, 211, 153, 0.2);
            border: 2px solid #34d399;
        }
        
        .state-indicator {
            text-align: center;
            padding: 10px;
            background: rgba(99, 102, 241, 0.05);
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .state-indicator .state-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 2px;
        }
        
        .state-indicator.coherent .state-name {
            color: #34d399;
        }
        
        .state-indicator.squeezed .state-name {
            color: #fbbf24;
        }
        
        .state-indicator .state-desc {
            color: #64748b;
            font-size: 10px;
        }
        
        .phase-legend {
            margin-top: 8px;
            padding-top: 10px;
            border-top: 1px solid rgba(99, 102, 241, 0.1);
        }
        
        .phase-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
            font-size: 10px;
            color: #94a3b8;
        }
        
        .phase-legend-color {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .phase-legend-color.ellipse {
            background: rgba(52, 211, 153, 0.2);
            border: 2px solid #34d399;
        }
        
        .phase-legend-color.classical {
            background: #1e293b;
            border: 2px solid #f472b6;
            width: 12px;
            height: 12px;
        }
        
        .katex { font-size: 1em; }
        
        .coherent-marker {
            position: absolute;
            font-size: 9px;
            color: #34d399;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="header-bar">
        <div class="title-section">
            <div class="title">Time Evolution ~ Quantum Harmonic Oscillator</div>
            <div class="info-icon-wrap">
                <span class="info-icon" aria-label="About this simulation">i</span>
                <div class="info-tooltip">
                    <div class="info-tooltip-title">About This Simulation</div>
                    <div class="info-panel">
                        <p>This simulation visualizes <span class="highlight">coherent states</span> in a quantum harmonic oscillator - special quantum states that most closely mimic classical motion.</p>
                        <p>The <span class="highlight">Gaussian wave packet</span> represents the probability density |Œ®(x,t)|¬≤, while the "ghost particle" follows the classical trajectory for comparison.</p>
                        <p>The coherent state width is given by:</p>
                        <div class="formula" id="coherentFormula"></div>
                        <p>When the width œÉ <span class="highlight" id="coherentValue">0.71</span> equals œÉ‚ÇÄ, the packet oscillates without changing shape (Coherent State). For <span class="highlight">any other width</span> (Squeezed States), the packet "breathes" at frequency 2œâ.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <div class="potential-section">
            <div class="section-header">
                <h3>Potential V(x) &amp; |Œ®(x,t)|¬≤</h3>
                <button type="button" class="maximize-btn" id="maximizePotential" aria-label="Maximize potential plot" title="Maximize">‚§¢</button>
            </div>
            <div id="canvas-container">
                <canvas id="mainCanvas"></canvas>
            </div>
        </div>
        
        <div class="phase-space-section">
            <div id="phase-space-container">
                <div class="phase-space-header">
                    <h3>Phase Space (x, p)</h3>
                    <button type="button" class="maximize-btn" id="maximizePhase" aria-label="Maximize phase space plot" title="Maximize">‚§¢</button>
                </div>
                <div id="phase-canvas-wrapper">
                    <canvas id="phaseCanvas"></canvas>
                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <!-- Stats Section -->
            <div class="panel-section">
                <div class="panel-section-title">üìà Statistics</div>
                <div class="stat-group">
                    <div class="stat">
                        <span class="stat-label">‚ü®x‚ü©</span>
                        <span class="stat-value" id="expectX">0.00</span>
                    </div>
                </div>
            </div>
            
            <!-- State Indicator -->
            <div class="panel-section">
                <div class="state-indicator" id="stateIndicator">
                    <div class="state-name">Coherent State</div>
                    <div class="state-desc">No breathing - classical-like motion</div>
                </div>
            </div>
            
            <!-- Controls Section -->
            <div class="panel-section">
                <div class="panel-section-title">üéõÔ∏è Controls</div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Displacement x‚ÇÄ</span>
                        <span class="value" id="x0Value">2.0</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="x0Slider" min="0" max="3" step="0.1" value="2">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>Width œÉ</span>
                        <span class="value" id="sigmaValue"></span>
                    </div>
                    <div class="slider-container">
                        <input type="range" class="slider" id="sigmaSlider" min="0.2" max="1.5" step="0.01">
                    </div>
                </div>
                
                <div class="btn-row">
                    <button class="btn btn-primary" id="playPauseBtn">
                        <span id="playIcon">‚ñ∂</span> Play
                    </button>
                    <button class="btn btn-secondary" id="resetBtn">
                        ‚Ü∫ Reset
                    </button>
                </div>
                
                <div class="btn-row" style="margin-top: 8px;">
                    <button class="btn btn-secondary" id="snapCoherentBtn"></button>
                </div>
                
                <label class="checkbox-container" id="classicalToggle">
                    <div class="checkbox checked" id="classicalCheckbox"></div>
                    <span>Show Classical Particle</span>
                </label>
            </div>
            
            <!-- Legend Section -->
            <div class="panel-section">
                <div class="panel-section-title">üé® Legend</div>
                <div class="legend-item">
                    <div class="legend-color potential"></div>
                    <span id="potentialLegend">Potential</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color wavefunction"></div>
                    <span>|Œ®(x,t)|¬≤ Probability Density</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color classical"></div>
                    <span>Classical Particle</span>
                </div>
                
                <div class="phase-legend">
                    <div style="font-size: 10px; color: #64748b; margin-bottom: 6px;">Phase Space:</div>
                    <div class="phase-legend-item">
                        <div class="phase-legend-color ellipse"></div>
                        <span>Uncertainty Ellipse</span>
                    </div>
                    <div class="phase-legend-item">
                        <div class="phase-legend-color classical"></div>
                        <span>Classical Particle</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const phaseCanvas = document.getElementById('phaseCanvas');
        const phaseCtx = phaseCanvas.getContext('2d');
        
        // Physics parameters (natural units: ‚Ñè = m = 1)
        let omega = 1.0;  // Angular frequency
        let x0 = 2.0;     // Initial displacement
        function getCoherentWidth() { return 1 / Math.sqrt(2 * omega); } // œÉ‚ÇÄ = ‚àö(‚Ñè/(2mœâ))
        let sigma = getCoherentWidth();  // Current width setting
        
        // Animation state
        let time = 0;
        let isPlaying = false;
        let showClassical = true;
        let lastFrameTime = 0;
        
        // UI Elements
        const x0Slider = document.getElementById('x0Slider');
        const sigmaSlider = document.getElementById('sigmaSlider');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const snapCoherentBtn = document.getElementById('snapCoherentBtn');
        const classicalToggle = document.getElementById('classicalToggle');
        const classicalCheckbox = document.getElementById('classicalCheckbox');
        const stateIndicator = document.getElementById('stateIndicator');
        
        // Stats displays
        const expectXDisplay = document.getElementById('expectX');
        const x0ValueDisplay = document.getElementById('x0Value');
        const sigmaValueDisplay = document.getElementById('sigmaValue');
        
        // Render LaTeX formulas and coherent width in UI
        function renderLatex() {
            // Potential legend
            const potentialLegend = document.getElementById('potentialLegend');
            katex.render('V(x) = \\frac{1}{2}kx^2', potentialLegend, { throwOnError: false });
            
            // Coherent width formula with numerical value
            const coherentFormula = document.getElementById('coherentFormula');
            katex.render('\\sigma_0 = \\sqrt{\\frac{\\hbar}{2m\\omega}} = ' + getCoherentWidth().toFixed(2), coherentFormula, { throwOnError: false, displayMode: true });
            const coherentValueEl = document.getElementById('coherentValue');
            if (coherentValueEl) coherentValueEl.textContent = getCoherentWidth().toFixed(2);
        }
        
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth * window.devicePixelRatio;
            canvas.height = container.clientHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            // Resize phase space canvas
            const phaseWrapper = document.getElementById('phase-canvas-wrapper');
            phaseCanvas.width = phaseWrapper.clientWidth * window.devicePixelRatio;
            phaseCanvas.height = phaseWrapper.clientHeight * window.devicePixelRatio;
            phaseCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        
        function getCanvasSize() {
            return {
                width: canvas.width / window.devicePixelRatio,
                height: canvas.height / window.devicePixelRatio
            };
        }
        
        function getPhaseCanvasSize() {
            return {
                width: phaseCanvas.width / window.devicePixelRatio,
                height: phaseCanvas.height / window.devicePixelRatio
            };
        }
        
        // Check if current sigma is exactly the coherent width
        function isCoherentState() {
            return Math.abs(sigma - getCoherentWidth()) < 0.001;
        }
        
        // Physics calculations (t is phase œâ¬∑t_physical)
        function getExpectationX(t) {
            return x0 * Math.cos(t);
        }
        
        function getExpectationP(t) {
            return -omega * x0 * Math.sin(t);
        }
        
        function getWidthAtTime(t) {
            // For coherent state, width stays constant
            if (isCoherentState()) {
                return sigma;
            }
            // For squeezed states, width oscillates (breathing)
            const cos2 = Math.cos(t) * Math.cos(t);
            const sin2 = Math.sin(t) * Math.sin(t);
            const s0 = getCoherentWidth();
            return Math.sqrt(sigma * sigma * cos2 + s0 * s0 * s0 * s0 / (sigma * sigma) * sin2);
        }
        
        function getMomentumWidthAtTime(t) {
            if (isCoherentState()) {
                return getCoherentWidth() * omega;
            }
            const cos2 = Math.cos(t) * Math.cos(t);
            const sin2 = Math.sin(t) * Math.sin(t);
            const s0 = getCoherentWidth();
            return Math.sqrt(s0 * s0 * s0 * s0 / (sigma * sigma) * cos2 + sigma * sigma * sin2) * omega;
        }
        
        function gaussian(x, mean, width) {
            const norm = 1 / (width * Math.sqrt(2 * Math.PI));
            const exp = Math.exp(-0.5 * Math.pow((x - mean) / width, 2));
            return norm * exp;
        }
        
        function potential(x) {
            return 0.5 * omega * omega * x * x;
        }
        
        // Coordinate transformations
        function physicsToCanvas(x, y, size) {
            const centerX = size.width / 2;
            const centerY = size.height * 0.7;
            const scaleX = size.width / 12;
            const scaleY = size.height / 8;
            return {
                x: centerX + x * scaleX,
                y: centerY - y * scaleY
            };
        }
        
        function phaseToCanvas(x, p, size) {
            const centerX = size.width / 2;
            const centerY = size.height / 2;
            const scale = Math.min(size.width, size.height) / 10;
            return {
                x: centerX + x * scale,
                y: centerY - p * scale
            };
        }
        
        function draw() {
            const size = getCanvasSize();
            
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, size.width, size.height);
            
            drawGrid(size);
            drawPotential(size);
            drawWaveFunction(size);
            
            if (showClassical) {
                drawClassicalParticle(size);
            }
            
            drawLabels(size);
            drawPhaseSpace();
            updateStats();
        }
        
        function drawGrid(size) {
            ctx.strokeStyle = 'rgba(99, 102, 241, 0.1)';
            ctx.lineWidth = 1;
            
            for (let x = -6; x <= 6; x++) {
                const p = physicsToCanvas(x, 0, size);
                ctx.beginPath();
                ctx.moveTo(p.x, 0);
                ctx.lineTo(p.x, size.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= 5; y++) {
                const p = physicsToCanvas(0, y, size);
                ctx.beginPath();
                ctx.moveTo(0, p.y);
                ctx.lineTo(size.width, p.y);
                ctx.stroke();
            }
        }
        
        function drawPotential(size) {
            function drawPotentialPath() {
                ctx.beginPath();
                for (let px = 0; px <= size.width; px++) {
                    const x = (px - size.width / 2) / (size.width / 12);
                    const V = potential(x);
                    const p = physicsToCanvas(x, V, size);
                    if (px === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
            }
            drawPotentialPath();
            ctx.strokeStyle = 'rgba(100, 116, 139, 0.3)';
            ctx.lineWidth = 6;
            ctx.stroke();
            drawPotentialPath();
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawWaveFunction(size) {
            const expectX = getExpectationX(time);
            const currentWidth = getWidthAtTime(time);
            
            const gradient = ctx.createLinearGradient(0, size.height * 0.3, 0, size.height * 0.7);
            gradient.addColorStop(0, 'rgba(129, 140, 248, 0.8)');
            gradient.addColorStop(1, 'rgba(99, 102, 241, 0.1)');
            
            ctx.beginPath();
            
            const baseY = physicsToCanvas(0, 0, size).y;
            let firstPoint = true;
            
            for (let px = 0; px <= size.width; px++) {
                const x = (px - size.width / 2) / (size.width / 12);
                const prob = gaussian(x, expectX, currentWidth);
                const scaledProb = prob * 2.5;
                const p = physicsToCanvas(x, scaledProb, size);
                
                if (firstPoint) {
                    ctx.moveTo(p.x, baseY);
                    ctx.lineTo(p.x, p.y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
            
            const lastP = physicsToCanvas(6, 0, size);
            ctx.lineTo(lastP.x, baseY);
            ctx.closePath();
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            function drawWaveOutline() {
                ctx.beginPath();
                for (let px = 0; px <= size.width; px++) {
                    const x = (px - size.width / 2) / (size.width / 12);
                    const prob = gaussian(x, expectX, currentWidth);
                    const scaledProb = prob * 2.5;
                    const p = physicsToCanvas(x, scaledProb, size);
                    if (px === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                }
            }
            drawWaveOutline();
            ctx.strokeStyle = 'rgba(165, 180, 252, 0.4)';
            ctx.lineWidth = 6;
            ctx.stroke();
            drawWaveOutline();
            ctx.strokeStyle = '#a5b4fc';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            const centerP = physicsToCanvas(expectX, gaussian(expectX, expectX, currentWidth) * 2.5, size);
            ctx.beginPath();
            ctx.arc(centerP.x, centerP.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#c4b5fd';
            ctx.fill();
        }
        
        function drawClassicalParticle(size) {
            const classicalX = getExpectationX(time);
            const classicalV = potential(classicalX);
            const p = physicsToCanvas(classicalX, classicalV, size);
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, 16, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(244, 114, 182, 0.2)';
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
            ctx.fillStyle = '#1e293b';
            ctx.fill();
            ctx.strokeStyle = '#f472b6';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            const velocity = getExpectationP(time);
            const arrowLength = velocity * 15;
            
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + arrowLength, p.y);
            ctx.strokeStyle = 'rgba(244, 114, 182, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            if (Math.abs(arrowLength) > 5) {
                const dir = arrowLength > 0 ? 1 : -1;
                ctx.beginPath();
                ctx.moveTo(p.x + arrowLength, p.y);
                ctx.lineTo(p.x + arrowLength - dir * 6, p.y - 4);
                ctx.lineTo(p.x + arrowLength - dir * 6, p.y + 4);
                ctx.closePath();
                ctx.fillStyle = 'rgba(244, 114, 182, 0.6)';
                ctx.fill();
            }
        }
        
        function drawPhaseSpace() {
            const size = getPhaseCanvasSize();
            
            phaseCtx.fillStyle = '#0a0e1a';
            phaseCtx.fillRect(0, 0, size.width, size.height);
            
            drawPhaseGrid(size);
            drawPhaseAxes(size);
            drawUncertaintyEllipse(size);
            
            if (showClassical) {
                drawClassicalInPhaseSpace(size);
            }
            
            drawPhaseLabels(size);
        }
        
        function drawPhaseGrid(size) {
            phaseCtx.strokeStyle = 'rgba(99, 102, 241, 0.1)';
            phaseCtx.lineWidth = 1;
            
            for (let x = -4; x <= 4; x++) {
                const p = phaseToCanvas(x, 0, size);
                phaseCtx.beginPath();
                phaseCtx.moveTo(p.x, 0);
                phaseCtx.lineTo(p.x, size.height);
                phaseCtx.stroke();
            }
            
            for (let y = -4; y <= 4; y++) {
                const p = phaseToCanvas(0, y, size);
                phaseCtx.beginPath();
                phaseCtx.moveTo(0, p.y);
                phaseCtx.lineTo(size.width, p.y);
                phaseCtx.stroke();
            }
        }
        
        function drawPhaseAxes(size) {
            const center = phaseToCanvas(0, 0, size);
            
            phaseCtx.strokeStyle = 'rgba(99, 102, 241, 0.4)';
            phaseCtx.lineWidth = 2;
            
            phaseCtx.beginPath();
            phaseCtx.moveTo(0, center.y);
            phaseCtx.lineTo(size.width, center.y);
            phaseCtx.stroke();
            
            phaseCtx.beginPath();
            phaseCtx.moveTo(center.x, 0);
            phaseCtx.lineTo(center.x, size.height);
            phaseCtx.stroke();
        }
        
        function drawUncertaintyEllipse(size) {
            const expectX = getExpectationX(time);
            const expectP = getExpectationP(time);
            const sigmaX = getWidthAtTime(time);
            const sigmaP = getMomentumWidthAtTime(time);
            
            const center = phaseToCanvas(expectX, expectP, size);
            const scale = Math.min(size.width, size.height) / 10;
            
            let a, b, rotationAngle;
            
            if (isCoherentState()) {
                // Coherent state: circular uncertainty (no rotation needed)
                a = sigma * scale;
                b = sigma * omega * scale;
                rotationAngle = 0;
            } else {
                // Squeezed state: ellipse rotates (time is phase)
                rotationAngle = -time;
                a = sigmaX * scale;
                b = sigmaP * scale;
            }
            
            phaseCtx.save();
            phaseCtx.translate(center.x, center.y);
            phaseCtx.rotate(rotationAngle);
            
            const contours = [2, 1.5, 1, 0.5];
            contours.forEach((contour, i) => {
                const alpha = 0.1 + i * 0.05;
                phaseCtx.beginPath();
                phaseCtx.ellipse(0, 0, a * contour, b * contour, 0, 0, Math.PI * 2);
                phaseCtx.fillStyle = `rgba(52, 211, 153, ${alpha})`;
                phaseCtx.fill();
            });
            
            function drawEllipseOutline() {
                phaseCtx.beginPath();
                phaseCtx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
            }
            drawEllipseOutline();
            phaseCtx.strokeStyle = 'rgba(52, 211, 153, 0.3)';
            phaseCtx.lineWidth = 6;
            phaseCtx.stroke();
            drawEllipseOutline();
            phaseCtx.strokeStyle = '#34d399';
            phaseCtx.lineWidth = 2;
            phaseCtx.stroke();
            
            phaseCtx.strokeStyle = 'rgba(52, 211, 153, 0.5)';
            phaseCtx.lineWidth = 1;
            phaseCtx.setLineDash([4, 4]);
            
            phaseCtx.beginPath();
            phaseCtx.moveTo(-a * 1.5, 0);
            phaseCtx.lineTo(a * 1.5, 0);
            phaseCtx.stroke();
            
            phaseCtx.beginPath();
            phaseCtx.moveTo(0, -b * 1.5);
            phaseCtx.lineTo(0, b * 1.5);
            phaseCtx.stroke();
            
            phaseCtx.setLineDash([]);
            phaseCtx.restore();
            
            drawProjectionIndicator(size, expectX, sigmaX);
        }
        
        function drawProjectionIndicator(size, expectX, sigmaX) {
            const scale = Math.min(size.width, size.height) / 10;
            const bottom = size.height - 30;
            
            const leftEdge = phaseToCanvas(expectX - sigmaX, 0, size).x;
            const rightEdge = phaseToCanvas(expectX + sigmaX, 0, size).x;
            const centerX = phaseToCanvas(expectX, 0, size).x;
            
            phaseCtx.strokeStyle = 'rgba(165, 180, 252, 0.6)';
            phaseCtx.lineWidth = 2;
            
            phaseCtx.beginPath();
            phaseCtx.moveTo(leftEdge, bottom - 10);
            phaseCtx.lineTo(leftEdge, bottom);
            phaseCtx.lineTo(rightEdge, bottom);
            phaseCtx.lineTo(rightEdge, bottom - 10);
            phaseCtx.stroke();
            
            phaseCtx.fillStyle = '#a5b4fc';
            phaseCtx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
            phaseCtx.textAlign = 'center';
            phaseCtx.fillText('Œîx projection', centerX, bottom + 15);
        }
        
        function drawClassicalInPhaseSpace(size) {
            const classicalX = getExpectationX(time);
            const classicalP = getExpectationP(time);
            const p = phaseToCanvas(classicalX, classicalP, size);
            
            phaseCtx.strokeStyle = 'rgba(244, 114, 182, 0.3)';
            phaseCtx.lineWidth = 1;
            phaseCtx.beginPath();
            
            for (let t = 0; t <= Math.PI * 2; t += 0.1) {
                const trailX = x0 * Math.cos(t);
                const trailP = -omega * x0 * Math.sin(t);
                const trailPoint = phaseToCanvas(trailX, trailP, size);
                if (t === 0) {
                    phaseCtx.moveTo(trailPoint.x, trailPoint.y);
                } else {
                    phaseCtx.lineTo(trailPoint.x, trailPoint.y);
                }
            }
            phaseCtx.closePath();
            phaseCtx.stroke();
            
            phaseCtx.beginPath();
            phaseCtx.arc(p.x, p.y, 12, 0, Math.PI * 2);
            phaseCtx.fillStyle = 'rgba(244, 114, 182, 0.2)';
            phaseCtx.fill();
            
            phaseCtx.beginPath();
            phaseCtx.arc(p.x, p.y, 8, 0, Math.PI * 2);
            phaseCtx.fillStyle = '#1e293b';
            phaseCtx.fill();
            phaseCtx.strokeStyle = '#f472b6';
            phaseCtx.lineWidth = 2;
            phaseCtx.stroke();
        }
        
        function drawPhaseLabels(size) {
            phaseCtx.fillStyle = '#64748b';
            phaseCtx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
            
            phaseCtx.textAlign = 'center';
            phaseCtx.fillText('Position x', size.width / 2, size.height - 8);
            
            phaseCtx.save();
            phaseCtx.translate(15, size.height / 2);
            phaseCtx.rotate(-Math.PI / 2);
            phaseCtx.fillText('Momentum p', 0, 0);
            phaseCtx.restore();
            
            phaseCtx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
            phaseCtx.textAlign = 'center';
            
            const center = phaseToCanvas(0, 0, size);
            
            [-3, -2, -1, 1, 2, 3].forEach(x => {
                const p = phaseToCanvas(x, 0, size);
                phaseCtx.fillText(x.toString(), p.x, center.y + 12);
            });
            
            phaseCtx.textAlign = 'right';
            [-3, -2, -1, 1, 2, 3].forEach(y => {
                const p = phaseToCanvas(0, y, size);
                phaseCtx.fillText(y.toString(), center.x - 5, p.y + 3);
            });
            
            phaseCtx.textAlign = 'right';
            phaseCtx.fillText('0', center.x - 5, center.y + 12);
        }
        
        function drawLabels(size) {
            ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#64748b';
            
            for (let x = -4; x <= 4; x += 2) {
                const p = physicsToCanvas(x, 0, size);
                ctx.fillText(x.toString(), p.x - 4, p.y + 20);
            }
            
            ctx.save();
            ctx.translate(30, size.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Energy / Probability', 0, 0);
            ctx.restore();
            
            ctx.fillText('Position x', size.width / 2 - 30, size.height - 20);
        }
        
        function updateStats() {
            const expectX = getExpectationX(time);
            expectXDisplay.textContent = expectX.toFixed(2);
        }
        
        function updateStateIndicator() {
            const s0 = getCoherentWidth();
            if (isCoherentState()) {
                stateIndicator.className = 'state-indicator coherent';
                stateIndicator.innerHTML = `
                    <div class="state-name">‚úì Coherent State (œÉ = ${s0.toFixed(2)})</div>
                    <div class="state-desc">No breathing - circular phase space - classical-like motion</div>
                `;
            } else if (sigma < s0) {
                stateIndicator.className = 'state-indicator squeezed';
                stateIndicator.innerHTML = `
                    <div class="state-name">‚ö† Squeezed State (Position)</div>
                    <div class="state-desc">œÉ = ${sigma.toFixed(2)} ‚â† ${s0.toFixed(2)} ‚Üí Breathing at 2œâ</div>
                `;
            } else {
                stateIndicator.className = 'state-indicator squeezed';
                stateIndicator.innerHTML = `
                    <div class="state-name">‚ö† Squeezed State (Momentum)</div>
                    <div class="state-desc">œÉ = ${sigma.toFixed(2)} ‚â† ${s0.toFixed(2)} ‚Üí Breathing at 2œâ</div>
                `;
            }
        }
        
        function updateSigmaDisplay() {
            if (isCoherentState()) {
                sigmaValueDisplay.textContent = sigma.toFixed(2) + ' (Coherent)';
                sigmaValueDisplay.style.color = '#34d399';
            } else {
                sigmaValueDisplay.textContent = sigma.toFixed(2) + ' (Squeezed)';
                sigmaValueDisplay.style.color = '#fbbf24';
            }
        }
        
        function animate(currentTime) {
            if (!lastFrameTime) lastFrameTime = currentTime;
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;
            
            if (isPlaying) {
                time += deltaTime * omega;
            }
            
            draw();
            requestAnimationFrame(animate);
        }
        
        // Event listeners
        x0Slider.addEventListener('input', (e) => {
            x0 = parseFloat(e.target.value);
            x0ValueDisplay.textContent = x0.toFixed(1);
        });
        
        sigmaSlider.addEventListener('input', (e) => {
            sigma = parseFloat(e.target.value);
            updateSigmaDisplay();
            updateStateIndicator();
        });
        
        snapCoherentBtn.addEventListener('click', () => {
            sigma = getCoherentWidth();
            sigmaSlider.value = sigma;
            updateSigmaDisplay();
            updateStateIndicator();
        });
        
        playPauseBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playPauseBtn.innerHTML = isPlaying ? 
                '<span>‚è∏</span> Pause' : 
                '<span>‚ñ∂</span> Play';
        });
        
        resetBtn.addEventListener('click', () => {
            time = 0;
            isPlaying = false;
            playPauseBtn.innerHTML = '<span>‚ñ∂</span> Play';
        });
        
        classicalToggle.addEventListener('click', () => {
            showClassical = !showClassical;
            classicalCheckbox.className = showClassical ? 'checkbox checked' : 'checkbox';
        });
        
        // Maximize plot windows
        const mainContainer = document.querySelector('.main-container');
        const maximizePotentialBtn = document.getElementById('maximizePotential');
        const maximizePhaseBtn = document.getElementById('maximizePhase');
        let maximizedPlot = null; // null | 'potential' | 'phase'
        
        function applyMaximizedState() {
            mainContainer.classList.remove('maximized-potential', 'maximized-phase');
            if (maximizedPlot === 'potential') mainContainer.classList.add('maximized-potential');
            if (maximizedPlot === 'phase') mainContainer.classList.add('maximized-phase');
            maximizePotentialBtn.textContent = maximizedPlot === 'potential' ? '‚äü' : '‚§¢';
            maximizePotentialBtn.setAttribute('aria-label', maximizedPlot === 'potential' ? 'Restore layout' : 'Maximize potential plot');
            maximizePotentialBtn.title = maximizedPlot === 'potential' ? 'Restore' : 'Maximize';
            maximizePhaseBtn.textContent = maximizedPlot === 'phase' ? '‚äü' : '‚§¢';
            maximizePhaseBtn.setAttribute('aria-label', maximizedPlot === 'phase' ? 'Restore layout' : 'Maximize phase space plot');
            maximizePhaseBtn.title = maximizedPlot === 'phase' ? 'Restore' : 'Maximize';
            requestAnimationFrame(() => resizeCanvas());
        }
        
        maximizePotentialBtn.addEventListener('click', () => {
            maximizedPlot = maximizedPlot === 'potential' ? null : 'potential';
            applyMaximizedState();
        });
        
        maximizePhaseBtn.addEventListener('click', () => {
            maximizedPlot = maximizedPlot === 'phase' ? null : 'phase';
            applyMaximizedState();
        });
        
        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        sigmaSlider.value = getCoherentWidth();
        snapCoherentBtn.textContent = '‚ö° Snap to Coherent (œÉ = ' + getCoherentWidth().toFixed(2) + ')';
        updateStateIndicator();
        updateSigmaDisplay();
        renderLatex();
        requestAnimationFrame(animate);
    </script>
</body>
</html>